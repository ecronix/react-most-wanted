{
  "_args": [
    [
      {
        "raw": "jws@https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
        "scope": null,
        "escapedName": "jws",
        "name": "jws",
        "rawSpec": "https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
        "spec": "https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
        "type": "remote"
      },
      "/var/srv/domains/smartscan.services/www/htdocs/rmw/functions/node_modules/firebase-admin"
    ]
  ],
  "_from": "jws@>=3.1.3 <4.0.0",
  "_id": "jws@3.1.4",
  "_inCache": true,
  "_location": "/firebase-admin/jws",
  "_phantomChildren": {},
  "_requested": {
    "raw": "jws@https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
    "scope": null,
    "escapedName": "jws",
    "name": "jws",
    "rawSpec": "https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
    "spec": "https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/firebase-admin",
    "/firebase-admin/jsonwebtoken"
  ],
  "_resolved": "https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
  "_shasum": "f9e8b9338e8a847277d6444b1464f61880e050a2",
  "_shrinkwrap": null,
  "_spec": "jws@https://registry.npmjs.org/jws/-/jws-3.1.4.tgz",
  "_where": "/var/srv/domains/smartscan.services/www/htdocs/rmw/functions/node_modules/firebase-admin",
  "author": {
    "name": "Brian J Brennan"
  },
  "bugs": {
    "url": "https://github.com/brianloveswords/node-jws/issues"
  },
  "dependencies": {
    "base64url": "^2.0.0",
    "jwa": "^1.1.4",
    "safe-buffer": "^5.0.1"
  },
  "description": "Implementation of JSON Web Signatures",
  "devDependencies": {
    "semver": "^5.1.0",
    "tape": "~2.14.0"
  },
  "directories": {
    "test": "test"
  },
  "gitHead": "c0f6b27bcea5a2ad2e304d91c2e842e4076a6b03",
  "homepage": "https://github.com/brianloveswords/node-jws#readme",
  "keywords": [
    "jws",
    "json",
    "web",
    "signatures"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "jws",
  "optionalDependencies": {},
  "readme": "# node-jws [![Build Status](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws)\n\nAn implementation of [JSON Web Signatures](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).\n\nThis was developed against `draft-ietf-jose-json-web-signature-08` and\nimplements the entire spec **except** X.509 Certificate Chain\nsigning/verifying (patches welcome).\n\nThere are both syncronous (`jws.sign`, `jws.verify`) and streaming\n(`jws.createSign`, `jws.createVerify`) APIs.\n\n# Install\n\n```bash\n$ npm install jws\n```\n\n# Usage\n\n## jws.ALGORITHMS\nArray of supported algorithms. The following algorithms are currently supported.\n\nalg Parameter Value | Digital Signature or MAC Algorithm\n----------------|----------------------------\nHS256 | HMAC using SHA-256 hash algorithm\nHS384 | HMAC using SHA-384 hash algorithm\nHS512 | HMAC using SHA-512 hash algorithm\nRS256 | RSASSA using SHA-256 hash algorithm\nRS384 | RSASSA using SHA-384 hash algorithm\nRS512 | RSASSA using SHA-512 hash algorithm\nES256 | ECDSA using P-256 curve and SHA-256 hash algorithm\nES384 | ECDSA using P-384 curve and SHA-384 hash algorithm\nES512 | ECDSA using P-521 curve and SHA-512 hash algorithm\nnone | No digital signature or MAC value included\n\n\n## jws.sign(options)\n\n(Synchronous) Return a JSON Web Signature for a header and a payload.\n\nOptions:\n\n* `header`\n* `payload`\n* `secret` or `privateKey`\n* `encoding` (Optional, defaults to 'utf8')\n\n`header` must be an object with an `alg` property. `header.alg` must be\none a value found in `jws.ALGORITHMS`. See above for a table of\nsupported algorithms.\n\nIf `payload` is not a buffer or a string, it will be coerced into a string\nusing `JSON.stringify`.\n\nExample\n\n```js\nconst signature = jws.sign({\n  header: { alg: 'HS256' },\n  payload: 'h. jon benjamin',\n  secret: 'has a van',\n});\n```\n\n## jws.verify(signature, algorithm, secretOrKey)\n\n(Synchronous) Returns`true` or `false` for whether a signature matches a\nsecret or key.\n\n`signature` is a JWS Signature. `header.alg` must be a value found in `jws.ALGORITHMS`.\nSee above for a table of supported algorithms. `secretOrKey` is a string or\nbuffer containing either the secret for HMAC algorithms, or the PEM\nencoded public key for RSA and ECDSA.\n\nNote that the `\"alg\"` value from the signature header is ignored.\n\n\n## jws.decode(signature)\n\n(Synchronous) Returns the decoded header, decoded payload, and signature\nparts of the JWS Signature.\n\nReturns an object with three properties, e.g.\n```js\n{ header: { alg: 'HS256' },\n  payload: 'h. jon benjamin',\n  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'\n}\n```\n\n## jws.createSign(options)\nReturns a new SignStream object.\n\nOptions:\n\n* `header` (required)\n* `payload`\n* `key` || `privateKey` || `secret`\n* `encoding` (Optional, defaults to 'utf8')\n\nOther than `header`, all options expect a string or a buffer when the\nvalue is known ahead of time, or a stream for convenience.\n`key`/`privateKey`/`secret` may also be an object when using an encrypted\nprivate key, see the [crypto documentation][encrypted-key-docs].\n\nExample\n```js\n\n// This...\njws.createSign({\n  header: { alg: 'RS256' },\n  privateKey: privateKeyStream,\n  payload: payloadStream,\n}).on('done', function(signature) {\n  // ...\n});\n\n// is equivilant to this:\nconst signer = jws.createSign(\n  header: { alg: 'RS256' },\n);\nprivateKeyStream.pipe(signer.privateKey);\npayloadStream.pipe(signer.payload);\nsigner.on('done', function(signature) {\n  // ...\n});\n```\n\n## jws.createVerify(options)\nReturns a new VerifyStream object.\n\nOptions:\n\n* `signature`\n* `algorithm`\n* `key` || `publicKey` || `secret`\n* `encoding` (Optional, defaults to 'utf8')\n\nAll options expect a string or a buffer when the value is known ahead of\ntime, or a stream for convenience.\n\nExample\n```js\n\n// This...\njws.createVerify({\n  publicKey: pubKeyStream,\n  signature: sigStream,\n}).on('done', function(verified, obj) {\n  // ...\n});\n\n// is equivilant to this:\nconst verifier = jws.createVerify();\npubKeyStream.pipe(verifier.publicKey);\nsigStream.pipe(verifier.signature);\nverifier.on('done', function(verified, obj) {\n  // ...\n});\n```\n\n## Class: SignStream\nA `Readable Stream` that emits a single data event, the calculated\nsignature, when done.\n\n### Event: 'done'\n`function (signature) { }`\n\n### signer.payload\n\nA `Writable Stream` that expects the JWS payload. Do *not* use if you\npassed a `payload` option to the constructor.\n\nExample\n\n```js\npayloadStream.pipe(signer.payload);\n```\n\n### signer.secret<br>signer.key<br>signer.privateKey\n\nA `Writable Stream`. Expects the JWS secret for HMAC, or the privateKey\nfor ECDSA and RSA. Do *not* use if you passed a `secret` or `key` option\nto the constructor.\n\nExample:\n\n```js\nprivateKeyStream.pipe(signer.privateKey);\n```\n\n## Class: VerifyStream\n\nThis is a `Readable Stream` that emits a single data event, the result\nof whether or not that signature was valid.\n\n### Event: 'done'\n`function (valid, obj) { }`\n\n`valid` is a boolean for whether or not the signature is valid.\n\n### verifier.signature\nA `Writable Stream` that expects a JWS Signature. Do *not* use if you\npassed a `signature` option to the constructor.\n\n### verifier.secret<br>verifier.key<br>verifier.publicKey\n\nA `Writable Stream` that expects a public key or secret. Do *not* use if you\npassed a `key` or `secret` option to the constructor.\n\n\n# TODO\n\n* It feels like there should be some convenience options/APIs for\n  defining the algorithm rather than having to define a header object\n  with `{ alg: 'ES512' }` or whatever every time.\n\n* X.509 support, ugh\n\n\n# License\n\nMIT\n\n```\nCopyright (c) 2013-2015 Brian J. Brennan\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n```\n\n[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianloveswords/node-jws.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "3.1.4"
}
